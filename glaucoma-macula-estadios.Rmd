---
title: "Clasifiación del Glaucoma en estadíos a partir del cubo macular"
date: "`r Sys.Date()`"
jupyter:
  kernelspec:
    display_name: R
    language: R
    name: ir
output:
    ipynbdocument::ipynb_document
---

```{r setup, include=F, cache = F, echo = F}
library(rmarkdown)
library(knitr)
## Global options
options(digits = 4)
opts_chunk$set(echo = F, cache = T, prompt = F, tidy = T, comment = NA, message = F, warning = F, dev = "svg")
```

```{r carga-paquetes, results='hide'}
.packages <- c("tidyverse", "tensorflow", "keras", "caret", "rcompanion", "kableExtra")
.installed <- .packages %in% installed.packages()
if (length(.packages[!.installed])>0) install.packages(.packages[!.installed])
lapply(.packages, require, character.only=T)
Sys.setenv(RETICULATE_PYTHON="/usr/bin/python")
```

```{r carga-datos}
# Carga de la base de datos (ver fichero glaucoma-preprocesamiento-datos.r)
load("data/data-macula-preprocesed.RData")
# Filter left eyes
df <- df.macula %>% filter(Ojo == "L")

# Conjunto de variables
varCells <- NULL
for (i in 1:8){
  for (j in 1:8){
    varCells <- c(varCells, paste0("Celda",j,".",i))
  }
}

# Eliminación datos atípicos
removeOutliers <- function(x) {
  qnt <- quantile(x, probs=c(.25, .75, 0.05, 0.95), na.rm = T)
  iqr <- qnt[2]-qnt[1]
  fence1 <- qnt[1]-1.5*iqr
  fence2 <- qnt[2]+1.5*iqr
  x[x < fence1] <- qnt[3]
  x[x > fence2] <- qnt[4]
  return(x)
}

df[df$Glaucoma=="Y" & df$Capa=="RNFL", varCells] <- sapply(df[df$Glaucoma=="Y" & df$Capa=="RNFL", varCells], removeOutliers)
df[df$Glaucoma=="N" & df$Capa=="RNFL", varCells ] <- sapply(df[df$Glaucoma=="N" & df$Capa=="RNFL", varCells], removeOutliers)
df[df$Glaucoma=="Y" & df$Capa=="GCL", varCells] <- sapply(df[df$Glaucoma=="Y" & df$Capa=="GCL", varCells], removeOutliers)
df[df$Glaucoma=="N" & df$Capa=="GCL", varCells ] <- sapply(df[df$Glaucoma=="N" & df$Capa=="GCL", varCells], removeOutliers)
df[df$Glaucoma=="Y" & df$Capa=="INL", varCells] <- sapply(df[df$Glaucoma=="Y" & df$Capa=="INL", varCells], removeOutliers)
df[df$Glaucoma=="N" & df$Capa=="INL", varCells ] <- sapply(df[df$Glaucoma=="N" & df$Capa=="INL", varCells], removeOutliers)
df[df$Glaucoma=="Y" & df$Capa=="IPL", varCells] <- sapply(df[df$Glaucoma=="Y" & df$Capa=="IPL", varCells], removeOutliers)
df[df$Glaucoma=="N" & df$Capa=="IPL", varCells ] <- sapply(df[df$Glaucoma=="N" & df$Capa=="IPL", varCells], removeOutliers)
df[df$Glaucoma=="Y" & df$Capa=="OPL", varCells] <- sapply(df[df$Glaucoma=="Y" & df$Capa=="OPL", varCells], removeOutliers)
df[df$Glaucoma=="N" & df$Capa=="OPL", varCells ] <- sapply(df[df$Glaucoma=="N" & df$Capa=="OPL", varCells], removeOutliers)
df[df$Glaucoma=="Y" & df$Capa=="ONL", varCells] <- sapply(df[df$Glaucoma=="Y" & df$Capa=="ONL", varCells], removeOutliers)
df[df$Glaucoma=="N" & df$Capa=="ONL", varCells ] <- sapply(df[df$Glaucoma=="N" & df$Capa=="ONL", varCells], removeOutliers)
df[df$Glaucoma=="Y" & df$Capa=="PRL", varCells] <- sapply(df[df$Glaucoma=="Y" & df$Capa=="PRL", varCells], removeOutliers)
df[df$Glaucoma=="N" & df$Capa=="PRL", varCells ] <- sapply(df[df$Glaucoma=="N" & df$Capa=="PRL", varCells], removeOutliers)
df[df$Glaucoma=="Y" & df$Capa=="RPE", varCells] <- sapply(df[df$Glaucoma=="Y" & df$Capa=="RPE", varCells], removeOutliers)
df[df$Glaucoma=="N" & df$Capa=="RPE", varCells ] <- sapply(df[df$Glaucoma=="N" & df$Capa=="RPE", varCells], removeOutliers)

# Añadir capa OPL+ONL
dfOPLONL <- cbind(df[df$Capa=="OPL", 1:4], df[df$Capa=="OPL", varCells] + df[df$Capa=="ONL", varCells])
dfOPLONL$Capa <- "OPL+ONL" 
df <- rbind(df, dfOPLONL)

# Load stages data
df.stages <- read_csv("data/data-stages.csv") %>% 
  select(-c(Ojo, Glaucoma, Sexo, Edad))
# Add stages to the dataframe
df <- df %>% inner_join(df.stages, by="Id") %>%
  # Move the stage column to the beginning
  select(Id, Glaucoma, Ojo, Estadio, everything())
```

# Resumen

En este trabajo se presenta un estudio de detección del Glaucoma y clasificación en estadíos (Sano, I, II, III y IV) a partir de las capas de fibras nerviosas de la mácula mediante redes neuronales. Los estadíos se han generado mediante el algoritmo de K-medias ([más info](https://aprendeconalf.es/glaucoma/glaucoma-clusters-izdo.html)).

Para cada capa o combinación de capas de la mácula se presenta primero un modelo de clasificación binaria (Sano o Glaucoma) para dectectar el Glaucoma y después un modelo de clasifiación múltiple para clasificar el glaucoma en estadíos (I, II, III y IV).

```{r default-parameters}
nrep = 3
nfolds = 10
nepochs = 100
nbatch = 50
```


```{r net functions, echo=F}
# function to prepare the input of glaucoma detection (binary classification)
prepare.input.glaucoma <- function(df, layers, cells = varCells){
  input <- df %>%
    # Filter layer
    filter(Capa %in% layers) %>%
    # Select cells
    select("Id", "Glaucoma", "Ojo", "Capa", "Estadio", cells) %>%
    # Convert to long format
    pivot_longer(-c(Id, Glaucoma, Ojo, Capa, Estadio), names_to = "cell") %>%
    # Join the layer and cell columns
    unite(temp, Capa, cell, sep = ".") %>%
    # Come back to wide format
    pivot_wider(names_from = temp, values_from = value)
  
  input <- input %>% 
    # Remove non numeric variables
    select(-c(Id, Ojo, Estadio)) %>%
    # Convert Glaucoma to numeric
    mutate(Glaucoma = as.numeric(Glaucoma)-1)
  
  # Look for rows with more than 20% of NA
  rows <- NULL
  for (i in 1:nrow(input)){
    if (sum(is.na(input[i,])) > (ncol(input) / 5)) {
      rows <- append(rows, i)
    }
  }
  # Remove rows from the data frame
  input <- input %>% slice(-rows)
  # Replace NAs by the column mean
  col_means <- lapply(input %>% select(-c(Glaucoma)), mean, na.rm = T)
  input <- input %>% replace_na(col_means)
  return(input)
}

# function to prepare the input of stages classification (multiple classification)
prepare.input.stages <- function(df, layers, cells = varCells){
  input <- df %>%
    # Filter glaucoma
    filter(Glaucoma == "Y") %>%
    # Filter layer
    filter(Capa %in% layers) %>%
    # Select cells
    select("Id", "Glaucoma", "Ojo", "Capa", "Estadio", cells) %>%
    # Convert to long format
    pivot_longer(-c(Id, Glaucoma, Ojo, Capa, Estadio), names_to = "cell") %>%
    # Join the layer and cell columns
    unite(temp, Capa, cell, sep = ".") %>%
    # Come back to wide format
    pivot_wider(names_from = temp, values_from = value)
  
  # Rename the stage levels to numbers
  input$Estadio <- recode_factor(input$Estadio, "I"=0, "II"=1, "III"=2, "IV"=3)
  
  input <- input %>% 
    # Remove non numeric variables
    select(-c(Id, Glaucoma, Ojo)) %>%
    # Convert state to numeric
    mutate(Estadio = as.numeric(Estadio)-1)
  
  # Look for rows with more than 20% of NA
  rows <- NULL
  for (i in 1:nrow(input)){
    if (sum(is.na(input[i,])) > (ncol(input) / 5)) {
      rows <- append(rows, i)
    }
  }
  # Remove rows from the data frame
  input <- input %>% slice(-rows)
  # Replace NAs by the column mean
  col_means <- lapply(input %>% select(-c(Estadio)), mean, na.rm = TRUE)
  input <- input %>% replace_na(col_means)
}

# Function to define the net architecture for binary classification
net.arch.glaucoma <-function(input.size){
  # Initialize a sequential model
  model <- keras_model_sequential() 
  # Add layers to the model
  model %>% 
    layer_dense(units = 1024, activation = "relu", input_shape = input.size) %>%
    layer_dense(units = 512, activation = "relu", input_shape = input.size) %>%
    layer_dropout(rate = 0.3) %>% 
    layer_dense(units = 512, activation = "relu", input_shape = input.size) %>% 
    layer_dropout(rate = 0.3) %>% 
    layer_dense(units = 256, activation = "relu", input_shape = input.size) %>% 
    layer_dropout(rate = 0.3) %>% 
    layer_dense(units = 128, activation = "relu") %>%
    layer_dropout(rate = 0.3) %>%
    layer_dense(units = 2, activation = "sigmoid")
  return(model_to_json(model))
}

# Function to define the net architecture for stages classification
net.arch.stages <-function(input.size){
  # Initialize a sequential model
  model <- keras_model_sequential() 
  # Add layers to the model
  model %>% 
    layer_dense(units = 1024, activation = "relu", input_shape = input.size) %>% 
    layer_dense(units = 512, activation = "relu", input_shape = input.size) %>% 
    layer_dropout(rate = 0.3) %>% 
    layer_dense(units = 256, activation = "relu", input_shape = input.size) %>% 
    layer_dropout(rate = 0.3) %>% 
    layer_dense(units = 128, activation = "relu") %>%
    layer_dropout(rate = 0.3) %>%
    layer_dense(units = 4, activation = "softmax")
  return(model_to_json(model))
}

# function for building and training nets for binary classification
net.glaucoma <- function(model.json, x, y, epochs=nepochs, batch_size=nbatch){
  # Initialize model
  model <- model_from_json(model.json)
  # Compile the model
  model %>% compile(
    loss = "binary_crossentropy",
    optimizer = "adam",
    metrics = "accuracy"
  )
  # Fit the model
  model %>% fit(x, to_categorical(y), epochs = epochs, batch_size = batch_size, validation_split = 0, verbose = 0)
  return(model)
}

# function for building and training nets for multiple classification
net.stages <- function(model.json, x, y, epochs=nepochs, batch_size=nbatch){
  # Initialize model
  model <- model_from_json(model.json)
  # Compile the model
  model %>% compile(
    loss = "categorical_crossentropy",
    optimizer = "adam",
    metrics = "accuracy"
  )
  # Fit the model
  model %>% fit(x, to_categorical(y), epochs = epochs, batch_size = batch_size, validation_split = 0, verbose = 0)
  return(model)
}

# Function to train several nets with crossvalidation
train.glaucoma <- function(input, epochs=nepochs, batch_size=nbatch){
  mean.sen <- NULL
  mean.spe <- NULL
  mean.acu <- NULL
  mean.bacu <- NULL
  # Set net architecture
  model.json <- net.arch.glaucoma(ncol(input)-1)
  for (i in 1:nrep){
    # cat("Repetición:", i, "\n")
    # Create k folds for cross-validation
    input$folds <- createFolds(input$Glaucoma, k=nfolds, list=F)
    # Vectors with sensitivities, specificities and accuracies of folds
    sen <- NULL
    spe <- NULL
    acu <- NULL
    bacu <- NULL
    for (j in unique(input$folds)){
      ind <- which(input$folds == j)
      train.x <- as.matrix(input[-ind, ] %>% select(-c("Glaucoma", "folds")))
      train.y <- as.matrix(input[-ind, "Glaucoma"])
      test.x <- as.matrix(input[ind, ] %>% select(-c("Glaucoma", "folds")))
      test.y <- as.matrix(input[ind, "Glaucoma"])
      # Clear the net
      k_clear_session()
      model <- net.glaucoma(model.json, train.x, train.y)
      # score <- model %>% evaluate(test.x, to_categorical(test.y), verbose = 0)
      # Model predictions
      #predictions <- model %>% predict_classes(test.x)
      predictions <-  model %>% predict(test.x) %>% `>`(0.5) 
      predictions <- as.integer(predictions[,2])
      # Confusion matrix
      confusion <- confusionMatrix(factor(predictions), factor(test.y), positive = "1")
      # Sensitivity
      sen <- c(sen, confusion$byClass["Sensitivity"])
      # Specificity
      spe <- c(spe, confusion$byClass["Specificity"])
      # Balanced accuracy
      bacu <- c(bacu, confusion$byClass["Balanced Accuracy"])
      # Accuracy
      acu <- c(acu, confusion$overall["Accuracy"])
    }
    mean.sen <- c(mean.sen, mean(sen))
    mean.spe <- c(mean.spe, mean(spe))
    mean.bacu <- c(mean.bacu, mean(bacu))
    mean.acu <- c(mean.acu, mean(acu))
  }
  # Summarise results
  scores <- data.frame("Sensibilidad" = mean.sen, "Especificidad" = mean.spe, "Precisión media" = mean.bacu, "Precisión global" = mean.acu) %>%
    pivot_longer(everything(), names_to = "Medida")
  result <- groupwiseMean(value ~ Medida, data = scores) %>%
    rename(Media = Mean, lim.inf.ci = Trad.lower, lim.sup.ci = Trad.upper) %>%
    select(-c(n,Conf.level))
  return(result)
}

# Function to train several nets with crossvalidation for multiple classification
train.stages <- function(input, epochs=nepochs, batch_size=nbatch){
  mean.sen <- NULL
  mean.spe <- NULL
  mean.acu <- NULL
  mean.bacu <- NULL
  # Set net architecture
  model.json <- net.arch.stages(ncol(input)-1)
  for (i in 1:nrep){
    #cat("Repetición:", i, "\n")
    # Create k folds for cross-validation
    input$folds <- createFolds(input$Estadio, k=nfolds, list=F)
    # Vectors with sensitivities, specificities and accuracies of folds
    sen <- NULL
    spe <- NULL
    acu <- NULL
    bacu <- NULL
    for (j in unique(input$folds)){
      ind <- which(input$folds == j)
      train.x <- as.matrix(input[-ind, ] %>% select(-c("Estadio", "folds")))
      train.y <- as.matrix(input[-ind, "Estadio"])
      test.x <- as.matrix(input[ind, ] %>% select(-c("Estadio", "folds")))
      test.y <- as.matrix(input[ind, "Estadio"])
      # Clear the net
      k_clear_session()
      model <- net.glaucoma(model.json, train.x, train.y)
      # score <- model %>% evaluate(test.x, to_categorical(test.y), verbose = 0)
      # Model predictions
      # predictions <- model %>% predict_classes(test.x)
      predictions <-  model %>% predict(test.x) %>% k_argmax() %>% as.integer()
      # Confusion matrix
      confusion <- confusionMatrix(factor(predictions), factor(test.y))
      # Sensitivity
      sen <- rbind(sen, confusion$byClass[ , "Sensitivity"])
      # Specificity
      spe <- rbind(spe, confusion$byClass[ , "Specificity"])
      # Balanced accuracy
      bacu <- rbind(bacu, confusion$byClass[ , "Balanced Accuracy"])
      # Accuracy
      acu <- c(acu, confusion$overall["Accuracy"])
    }
    mean.sen <- rbind(mean.sen, colMeans(sen))
    mean.spe <- rbind(mean.spe, colMeans(spe))
    mean.bacu <- rbind(mean.bacu, colMeans(bacu))
    mean.acu <- c(mean.acu, mean(acu))
  }
  mean.sen <- as.tibble(mean.sen) %>% rename(EstadioI = `Class: 0`, EstadioII = `Class: 1`, EstadioIII = `Class: 2`, EstadioIV = `Class: 3`)
  mean.spe <- as.tibble(mean.spe) %>% rename(EstadioI = `Class: 0`, EstadioII = `Class: 1`, EstadioIII = `Class: 2`, EstadioIV = `Class: 3`)
  mean.bacu <- as.tibble(mean.bacu) %>% rename(EstadioI = `Class: 0`, EstadioII = `Class: 1`, EstadioIII = `Class: 2`, EstadioIV = `Class: 3`)
  # Summarise results
  acu <- groupwiseMean(Precisión.global~1, data = data.frame("Precisión.global" = mean.acu)) %>% rename(Medida = `.id`)
  acu$Medida <- "Precisión.global"
  scores <- data.frame("Sensibilidad" = mean.sen, "Especificidad" = mean.spe, "Precisión media" = mean.bacu) %>%
    pivot_longer(everything(), names_to = "Medida")
  result <- groupwiseMean(value ~ Medida, data = scores) %>% 
    union(acu) %>%
    rename(Media = Mean, lim.inf.ci = Trad.lower, lim.sup.ci = Trad.upper) %>%
    select(-c(n,Conf.level))
  return(result)
}
```

# Capa RNFL

## Detección del Glaucoma

### Parámetros de la red

- Arquitectura 

```{r net-glaucoma-rnfl-arch}
#cells = varCells[c(25,33,34,40,41,42,43,47,48,49,50,51,55,56,57,58,59,60,61,62,63,64)]
input <- prepare.input.glaucoma(df, layers = "RNFL")
model.json <- net.arch.glaucoma(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía binaria
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-glaucoma-rnfl-eval}
train.glaucoma(input) %>%  
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```

## Clasificación en estadíos

### Parámetros de la red

- Arquitectura

```{r net-stages-rnfl-arch}
input <- prepare.input.stages(df, layers = "RNFL")
model.json <- net.arch.stages(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía múltiple
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-stages-rnfl-eval}
train.stages(input) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```

# Capa GCL

## Detección del Glaucoma

### Parámetros de la red

- Arquitectura 

```{r net-glaucoma-gcl-arch}
input <- prepare.input.glaucoma(df, layers = "GCL")
model.json <- net.arch.glaucoma(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía binaria
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-glaucoma-gcl-eval}
train.glaucoma(input) %>%  
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```

## Clasificación en estadíos

### Parámetros de la red

- Arquitectura

```{r net-stages-gcl-arch}
input <- prepare.input.stages(df, layers = "GCL")
model.json <- net.arch.stages(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía múltiple
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-stages-gcl-eval}
train.stages(input) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```


# Capa IPL

## Detección del Glaucoma

### Parámetros de la red

- Arquitectura 

```{r net-glaucoma-ipl-arch}
input <- prepare.input.glaucoma(df, layers = "IPL")
model.json <- net.arch.glaucoma(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía binaria
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-glaucoma-ipl-eval}
train.glaucoma(input) %>%  
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```

## Clasificación en estadíos

### Parámetros de la red

- Arquitectura

```{r net-stages-ipl-arch}
input <- prepare.input.stages(df, layers = "IPL")
model.json <- net.arch.stages(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía múltinle
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-stages-inl-eval}
train.stages(input) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```

# Capas RNFL + GCL + IPL

## Detección del Glaucoma

### Parámetros de la red

- Arquitectura 

```{r net-glaucoma-rnfl-gcl-inl-arch}
input <- prepare.input.glaucoma(df, layers = c("RNFL", "GCL", "IPL"))
model.json <- net.arch.glaucoma(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía binaria
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-glaucoma-rnfl-gcl-inl-eval}
train.glaucoma(input) %>%  
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```

## Clasificación en estadíos

### Parámetros de la red

- Arquitectura

```{r net-stages-rnfl-gcl-inl-arch}
input <- prepare.input.stages(df, layers = c("RNFL", "GCL", "IPL"))
model.json <- net.arch.stages(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía múltrnfl-gcl-inle
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-stages-rnfl-gcl-inl-eval}
train.stages(input) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```

# Capas RNFL + GCL + INL + IPL + OPL + ONL + PRL + RPE

## Detección del Glaucoma

### Parámetros de la red

- Arquitectura 

```{r net-glaucoma-all-arch}
input <- prepare.input.glaucoma(df, layers = c("RNFL", "GCL", "INL", "IPL", "OPL+ONL" , "PRL", "RPE"))
model.json <- net.arch.glaucoma(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía binaria
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-glaucoma-all-eval}
train.glaucoma(input) %>%  
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```

## Clasificación en estadíos

### Parámetros de la red

- Arquitectura

```{r net-stages-all-arch}
input <- prepare.input.stages(df, layers = c("RNFL", "GCL", "INL", "IPL", "OPL+ONL" , "PRL", "RPE"))
model.json <- net.arch.stages(ncol(input)-1)
summary(model_from_json(model.json))
```

- Número de iteraciones: `r nepochs`
- Tamaño del lote: `r nbatch`
- Medida de error: Entropía múltalle
- Algorimo de aprendizaje: Adam
- Validación cruzada: `r nfolds`-folds
- Número de repeticiones: `r nrep`

### Evaluación del modelo

```{r net-stages-all-eval}
train.stages(input) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = "hover", full_width = F)
```


# Análisis discriminante

```{r lda functions, echo=F}
# function to prepare the input of glaucoma detection (binary classification)
df.sig <- read_csv("data/significant-cells.csv") 

lda.input.glaucoma <- function(df, layers, cells = varCells){
  cells = varCells
  layers = "RNFL"
  # Get cells with a significant difference.
  sig.cells <- df.sig %>%
    filter(Capa %in% layers) %>%
    unite(var, Capa, Celda, sep = ".")
  
  input <- df %>%
    # Filter layer
    filter(Capa %in% layers) %>%
    # Select cells
    select("Id", "Glaucoma", "Ojo", "Capa", "Estadio", cells) %>%
    # Convert to long format
    pivot_longer(-c(Id, Glaucoma, Ojo, Capa, Estadio), names_to = "cell") %>%
    # Join the layer and cell columns
    unite(var, Capa, cell, sep = ".") %>%
    # Right join with significant cells
    right_join(sig.cells) %>%
    # Come back to wide format
    pivot_wider(names_from = var, values_from = value)
  
  input <- input %>% 
    # Remove non numeric variables
    select(-c(Id, Ojo, Estadio)) %>%
    # Convert Glaucoma to numeric
    mutate(Glaucoma = as.numeric(Glaucoma)-1)
  
  # Look for rows with more than 20% of NA
  rows <- NULL
  for (i in 1:nrow(input)){
    if (sum(is.na(input[i,])) > (ncol(input) / 5)) {
      rows <- append(rows, i)
    }
  }
  # Remove rows from the data frame
  input <- input %>% slice(-rows)
  # Replace NAs by the column mean
  col_means <- lapply(input %>% select(-c(Glaucoma)), mean, na.rm = T)
  input <- input %>% replace_na(col_means)
  return(input)
}
```

```{r}
library("MASS")
input <- lda.input.glaucoma(df, layers = "RNFL")
classify <- function(df){
  # Compute principal components
  result.pca <- df %>%
    select(-Glaucoma) %>%
    prcomp(center = F, scale = F)
  # Add principal components coordinates to a data frame  
  df.pca <- as.data.frame(result.pca$x)
  # Add cluster to principal components data frame
  df.pca$Glaucoma <- df$Glaucoma
  # Linear discriminant
  result.lda <- lda(Glaucoma~., data=df.pca)
  result.eval <- lda(Glaucoma~., data=df.pca, CV=T)
  # Model goodness
  performance <- confusionMatrix(factor(result.eval$class), factor(df.pca$Glaucoma))
  colnames(performance$byClass) <- c("Sensibilidad", "Especificidad", "VPP", "VPN", "Precisión", "Exhaustividad", "Medida.F", "Prevalencia", "Detection.Rate", "Detection.Prevalence", "Precisión.Global")
  rownames(performance$byClass) <- gsub("Class:", "Estadio", rownames(performance$byClass))
  performance$byClass <- performance$byClass[, c("Sensibilidad","Especificidad","Precisión.Global")]
  return(list(pc = result.pca, da = result.lda, performance = performance))
}
result <- classify(input)
```

